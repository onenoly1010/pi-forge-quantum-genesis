name: ðŸšª Auto-Close Stale PRs

on:
  schedule:
    # Run daily at 3:00 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (do not close, only report)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  close-stale-prs:
    runs-on: ubuntu-latest
    name: Close PRs Inactive for 30+ Days
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Find and close stale PRs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'true' }}
        run: |
          echo "ðŸ” Scanning for PRs inactive for 30+ days..."
          echo "Dry run mode: $DRY_RUN"
          
          # Get current date in seconds
          CURRENT_DATE=$(date +%s)
          THIRTY_DAYS_AGO=$((CURRENT_DATE - 30*24*60*60))
          
          # Use temp files to track counts (avoid subshell variable issues)
          echo "0" > /tmp/closed_count.txt
          echo "0" > /tmp/skipped_count.txt
          
          # Get all open PRs
          PR_DATA=$(gh pr list --state open --json number,updatedAt,labels,title,author --limit 1000)
          
          echo "$PR_DATA" | jq -c '.[]' | while read -r pr; do
            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            PR_TITLE=$(echo "$pr" | jq -r '.title')
            PR_AUTHOR=$(echo "$pr" | jq -r '.author.login')
            UPDATED_AT=$(echo "$pr" | jq -r '.updatedAt')
            LABELS=$(echo "$pr" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
            
            # Check if PR has 'do-not-close' label
            if echo "$LABELS" | grep -qi "do-not-close"; then
              echo "â­ï¸  Skipping PR #$PR_NUMBER (has 'do-not-close' label)"
              echo $(($(cat /tmp/skipped_count.txt) + 1)) > /tmp/skipped_count.txt
              continue
            fi
            
            # Convert updated_at to seconds
            UPDATED_SECONDS=$(date -d "$UPDATED_AT" +%s 2>/dev/null || echo "0")
            
            if [ "$UPDATED_SECONDS" -eq 0 ]; then
              echo "âš ï¸  Could not parse date for PR #$PR_NUMBER, skipping"
              echo $(($(cat /tmp/skipped_count.txt) + 1)) > /tmp/skipped_count.txt
              continue
            fi
            
            # Calculate age in days
            AGE_SECONDS=$((CURRENT_DATE - UPDATED_SECONDS))
            AGE_DAYS=$((AGE_SECONDS / 86400))
            
            if [ "$AGE_DAYS" -ge 30 ]; then
              if [ "$DRY_RUN" = "true" ]; then
                echo "ðŸ” [DRY RUN] Would close PR #$PR_NUMBER: \"$PR_TITLE\" (inactive for $AGE_DAYS days)"
                echo $(($(cat /tmp/closed_count.txt) + 1)) > /tmp/closed_count.txt
              else
                echo "Closing PR #$PR_NUMBER: \"$PR_TITLE\" (inactive for $AGE_DAYS days)"
                
                # Add comment explaining the closure
                gh pr comment "$PR_NUMBER" --body "Automated Closure Notice - This pull request has been automatically closed due to inactivity. PRs inactive for 30+ days are automatically closed to maintain a clean workspace as part of our autonomous cleanup protocol. You can reopen this PR at any time or add the do-not-close label to prevent future automatic closure. This follows the Quantum Pi Forge principle of continuity. Closed by: Automated Cleanup Protocol"
                
                # Close the PR
                gh pr close "$PR_NUMBER" --comment "Automatically closed due to 30 days of inactivity. Can be reopened if work resumes."
                
                echo $(($(cat /tmp/closed_count.txt) + 1)) > /tmp/closed_count.txt
              fi
            else
              echo "âœ“ Keeping PR #$PR_NUMBER (active $AGE_DAYS days ago)"
            fi
          done
          
          # Read final counts from temp files
          CLOSED_COUNT=$(cat /tmp/closed_count.txt)
          SKIPPED_COUNT=$(cat /tmp/skipped_count.txt)
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“Š Summary:"
          if [ "$DRY_RUN" = "true" ]; then
            echo "   PRs that would be closed: $CLOSED_COUNT"
          else
            echo "   PRs closed: $CLOSED_COUNT"
          fi
          echo "   PRs skipped: $SKIPPED_COUNT"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: Create closure report
        if: always()
        run: |
          mkdir -p reports
          cat > reports/pr-closure-$(date +%Y%m%d-%H%M%S).txt << EOF
          PR Closure Report
          =================
          Date: $(date -u)
          Dry Run: ${{ github.event.inputs.dry_run || 'true' }}
          
          This automated workflow closes pull requests that have been
          inactive for 30+ days (no commits, comments, or updates).
          
          PRs with the 'do-not-close' label are never automatically closed.
          
          Closed PRs can be reopened at any time by contributors.
          EOF
          
          echo "âœ… Closure report generated"
      
      - name: Post summary
        if: always()
        run: |
          echo "### ðŸšª PR Closure Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: ${{ github.event.inputs.dry_run || 'true' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Date**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "PRs inactive for 30+ days (without 'do-not-close' label) were processed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note**: Closed PRs can be reopened at any time." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To prevent automatic closure, add the \`do-not-close\` label to a PR." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "See workflow logs for detailed information." >> $GITHUB_STEP_SUMMARY
