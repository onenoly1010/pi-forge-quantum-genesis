name: "Deploy → Testnet (Safe & Automated)"
on:
  workflow_dispatch:
    inputs:
      confirm_testnet:
        description: "Type 'testnet' to confirm deployment target"
        required: true
        default: "testnet"
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - 'docs/**'
permissions:
  contents: read
  packages: write
  deployments: write
env:
  REGISTRY: ghcr.io
  IMAGE_BASE: ghcr.io/${{ github.repository_owner }}/pi-forge-quantum-genesis

jobs:
  safety-gate:
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
    steps:
      - name: Enforce testnet-only deployment
        id: check
        run: |
          if [[ "${{ github.event.inputs.confirm_testnet || 'testnet' }}" != "testnet" ]]; then
            echo "Deployment target must be 'testnet'" >&2
            exit 1
          fi
          if [[ "${{ secrets.GUARDIAN_KILL_SWITCH || 'off' }}" == "on" ]]; then
            echo "GUARDIAN_KILL_SWITCH is ON — deployment blocked" >&2
            exit 1
          fi
          if [[ "${{ secrets.NFT_MINT_VALUE || '0' }}" != "0" ]]; then
            echo "NFT_MINT_VALUE must be 0 on testnet" >&2
            exit 1
          fi
          echo "proceed=true" > $GITHUB_OUTPUT
  test-and-build:
    needs: safety-gate
    if: needs.safety-gate.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with: { python-version: '3.11' }
      - name: Test Guardian Coordinator
        run: |
          pip install -r guardian-coordinator/requirements.txt pytest
          pytest guardian-coordinator/tests -q
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build & Push All Images
        run: |
          TAG=${{ github.sha }}
          services=("guardian-coordinator" "fastapi-server" "flask-dashboard" "gradio-interface")
          for svc in "${services[@]}"; do
            IMAGE="${{ env.IMAGE_BASE }}-$svc:$TAG"
            echo "Building $IMAGE"
            docker build -t "$IMAGE" -f docker/Dockerfile.$svc .
            docker push "$IMAGE"
            echo "$svc_IMAGE=$IMAGE" > $GITHUB_ENV
          done
  deploy-railway:
    needs: test-and-build
    runs-on: ubuntu-latest
    environment: testnet
    steps:
      - name: Deploy to Railway
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        run: |
          npm i -g @railway/cli
          railway login --token "$RAILWAY_TOKEN"
          railway link ${{ secrets.RAILWAY_PROJECT_ID }}
         
          railway service guardian-coordinator --image ${{ env.guardian-coordinator_IMAGE }}
          railway service fastapi-server --image ${{ env.fastapi-server_IMAGE }}
          railway service flask-dashboard --image ${{ env.flask-dashboard_IMAGE }}
          railway service gradio-interface --image ${{ env.gradio-interface_IMAGE }}
         
          railway up --detach
  smoke-test:
    needs: deploy-railway
    runs-on: ubuntu-latest
    steps:
      - name: Wait for services
        run: sleep 45
      - name: Run smoke tests
        env:
          GUARDIAN_API_URL: ${{ secrets.TESTNET_GUARDIAN_URL }}
          FASTAPI_URL: ${{ secrets.TESTNET_FASTAPI_URL }}
          FLASK_URL: ${{ secrets.TESTNET_FLASK_URL }}
          GRADIO_URL: ${{ secrets.TESTNET_GRADIO_URL }}
        run: |
          curl --fail -s ${{ env.GUARDIAN_API_URL }}/health
          curl --fail -s ${{ env.FASTAPI_URL }}
          curl --fail -s ${{ env.FLASK_URL }}
          curl --fail -s ${{ env.GRADIO_URL }}
          echo "All services healthy!"
  mark-deployment:
    needs: smoke-test
    runs-on: ubuntu-latest
    steps:
      - name: Mark success
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.run_id,
              state: 'success',
              environment: 'testnet'
            })
